###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2014  19:26:48 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\stm32\STM32F10XFWLIB\src\stm32f10x_spi.c              #
#    Command line =  D:\stm32\STM32F10XFWLIB\src\stm32f10x_spi.c -D           #
#                    VECT_TAB_FLASH -lCN "D:\stm32\BLDC                       #
#                    PMSM2\EWARM\Debug\List\" --diag_error Pe068,Pe069 -o     #
#                    "D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\" --debug           #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\" -I "D:\stm32\BLDC        #
#                    PMSM2\EWARM\..\..\STM32F10XFWLIB\inc\" -I                #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\inc\" -Oh                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\stm32\BLDC PMSM2\EWARM\Debug\List\stm32f10x_spi.lst   #
#    Object file  =  D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\stm32f10x_spi.o      #
#                                                                             #
#                                                                             #
###############################################################################

D:\stm32\STM32F10XFWLIB\src\stm32f10x_spi.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_spi.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0 
      5          * Date               : 05/23/2008
      6          * Description        : This file provides all the SPI firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
     15          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     16          *******************************************************************************/
     17          
     18          /* Includes ------------------------------------------------------------------*/
     19          #include "stm32f10x_spi.h"
     20          #include "stm32f10x_rcc.h"
     21          
     22          /* Private typedef -----------------------------------------------------------*/
     23          /* Private define ------------------------------------------------------------*/
     24          /* SPI SPE mask */
     25          #define CR1_SPE_Set          ((u16)0x0040)
     26          #define CR1_SPE_Reset        ((u16)0xFFBF)
     27          
     28          /* I2S I2SE mask */
     29          #define I2SCFGR_I2SE_Set     ((u16)0x0400)
     30          #define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
     31          
     32          /* SPI CRCNext mask */
     33          #define CR1_CRCNext_Set      ((u16)0x1000)
     34          
     35          /* SPI CRCEN mask */
     36          #define CR1_CRCEN_Set        ((u16)0x2000)
     37          #define CR1_CRCEN_Reset      ((u16)0xDFFF)
     38          
     39          /* SPI SSOE mask */
     40          #define CR2_SSOE_Set         ((u16)0x0004)
     41          #define CR2_SSOE_Reset       ((u16)0xFFFB)
     42          
     43          /* SPI registers Masks */
     44          #define CR1_CLEAR_Mask       ((u16)0x3040)
     45          #define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
     46          
     47          /* SPI or I2S mode selection masks */
     48          #define SPI_Mode_Select      ((u16)0xF7FF)
     49          #define I2S_Mode_Select      ((u16)0x0800)   
     50          
     51          /* Private macro -------------------------------------------------------------*/
     52          /* Private variables ---------------------------------------------------------*/
     53          /* Private function prototypes -----------------------------------------------*/
     54          /* Private functions ---------------------------------------------------------*/
     55          
     56          /*******************************************************************************
     57          * Function Name  : SPI_I2S_DeInit
     58          * Description    : Deinitializes the SPIx peripheral registers to their default
     59          *                  reset values (Affects also the I2Ss).
     60          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
     61          * Output         : None
     62          * Return         : None
     63          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
     65          {
   \                     SPI_I2S_DeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     66            /* Check the parameters */
     67            assert_param(IS_SPI_ALL_PERIPH(SPIx));
     68            
     69            switch (*(u32*)&SPIx)
   \   00000002   0x....             LDR.N    R1,??DataTable0  ;; 0x40003800
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD011             BEQ.N    ??SPI_I2S_DeInit_0
   \   00000008   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40003c00
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD017             BEQ.N    ??SPI_I2S_DeInit_1
   \   0000000E   0x....             LDR.N    R1,??DataTable0_2  ;; 0x40013000
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD120             BNE.N    ??SPI_I2S_DeInit_2
     70            {
     71              case SPI1_BASE:
     72                /* Enable SPI1 reset state */
     73                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF44F 0x5080      MOV      R0,#+4096
   \   0000001A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     74                /* Release SPI1 from reset state */
     75                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF44F 0x5080      MOV      R0,#+4096
   \   00000024   0xE8BD 0x4004      POP      {R2,LR}
   \   00000028   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     76                break;
     77          
     78              case SPI2_BASE:
     79                /* Enable SPI2 reset state */
     80                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \                     ??SPI_I2S_DeInit_0:
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000032   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     81                /* Release SPI2 from reset state */
     82                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003C   0xE007             B.N      ??SPI_I2S_DeInit_3
     83                break;
     84          
     85              case SPI3_BASE:
     86                /* Enable SPI3 reset state */
     87                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \                     ??SPI_I2S_DeInit_1:
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF44F 0x4000      MOV      R0,#+32768
   \   00000044   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     88                /* Release SPI3 from reset state */
     89                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF44F 0x4000      MOV      R0,#+32768
   \                     ??SPI_I2S_DeInit_3:
   \   0000004E   0xE8BD 0x4004      POP      {R2,LR}
   \   00000052   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
     90                break;
     91          
     92              default:
     93                break;
     94            }
     95          }
   \                     ??SPI_I2S_DeInit_2:
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
     96          
     97          /*******************************************************************************
     98          * Function Name  : SPI_Init
     99          * Description    : Initializes the SPIx peripheral according to the specified 
    100          *                  parameters in the SPI_InitStruct.
    101          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    102          *                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    103          *                    contains the configuration information for the specified
    104          *                    SPI peripheral.
    105          * Output         : None
    106          * Return         : None
    107          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    109          {
    110            u16 tmpreg = 0;
    111            
    112            /* check the parameters */
    113            assert_param(IS_SPI_ALL_PERIPH(SPIx));   
    114            
    115            /* Check the SPI parameters */
    116            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    117            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    118            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    119            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    120            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    121            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    122            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    123            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    124            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    125          
    126          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    127            /* Get the SPIx CR1 value */
    128            tmpreg = SPIx->CR1;
    129            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    130            tmpreg &= CR1_CLEAR_Mask;
    131            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    132               master/salve mode, CPOL and CPHA */
    133            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    134            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    135            /* Set LSBFirst bit according to SPI_FirstBit value */
    136            /* Set BR bits according to SPI_BaudRatePrescaler value */
    137            /* Set CPOL bit according to SPI_CPOL value */
    138            /* Set CPHA bit according to SPI_CPHA value */
    139            tmpreg |= (u16)((u32)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    140                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    141                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    142                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
    143            /* Write to SPIx CR1 */
    144            SPIx->CR1 = tmpreg;
   \                     SPI_Init:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF402 0x5241      AND      R2,R2,#0x3040
   \   00000006   0x880B             LDRH     R3,[R1, #+0]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x884B             LDRH     R3,[R1, #+2]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x888B             LDRH     R3,[R1, #+4]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x88CB             LDRH     R3,[R1, #+6]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x890B             LDRH     R3,[R1, #+8]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x894B             LDRH     R3,[R1, #+10]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x898B             LDRH     R3,[R1, #+12]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x89CB             LDRH     R3,[R1, #+14]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x8002             STRH     R2,[R0, #+0]
    145            
    146            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    147            SPIx->I2SCFGR &= SPI_Mode_Select;		
   \   00000028   0x8B82             LDRH     R2,[R0, #+28]
   \   0000002A   0xF24F 0x73FF      MOVW     R3,#+63487
   \   0000002E   0x401A             ANDS     R2,R3,R2
   \   00000030   0x8382             STRH     R2,[R0, #+28]
    148          
    149          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    150            /* Write to SPIx CRCPOLY */
    151            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000032   0x8A09             LDRH     R1,[R1, #+16]
   \   00000034   0x8201             STRH     R1,[R0, #+16]
    152          }
   \   00000036   0x4770             BX       LR               ;; return
    153          
    154          /*******************************************************************************
    155          * Function Name  : I2S_Init
    156          * Description    : Initializes the SPIx peripheral according to the specified 
    157          *                  parameters in the I2S_InitStruct.
    158          * Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
    159          *                     (configured in I2S mode).
    160          *                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    161          *                    contains the configuration information for the specified
    162          *                    SPI peripheral configured in I2S mode.
    163          * Output         : None
    164          * Return         : None
    165          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    166          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    167          {
   \                     I2S_Init:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    168            u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000008   0x2701             MOVS     R7,#+1
    169            u32 tmp = 0;
    170            RCC_ClocksTypeDef RCC_Clocks;
    171             
    172            /* Check the I2S parameters */
    173            assert_param(IS_SPI_23_PERIPH(SPIx));
    174            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    175            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    176            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    177            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    178            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    179            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    180          
    181          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    182          
    183            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    184            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
   \   0000000A   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000000C   0xF24F 0x0140      MOVW     R1,#+61504
   \   00000010   0x4008             ANDS     R0,R1,R0
   \   00000012   0x83A0             STRH     R0,[R4, #+28]
    185            SPIx->I2SPR = 0x0002;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x8420             STRH     R0,[R4, #+32]
    186            
    187            /* Get the I2SCFGR register value */
    188            tmpreg = SPIx->I2SCFGR;
   \   00000018   0x8BA6             LDRH     R6,[R4, #+28]
    189            
    190            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    191            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   0000001A   0x8928             LDRH     R0,[R5, #+8]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD102             BNE.N    ??I2S_Init_0
    192            {
    193              i2sodd = (u16)0;
   \   00000020   0x2000             MOVS     R0,#+0
    194              i2sdiv = (u16)2;   
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0xE01E             B.N      ??I2S_Init_1
    195            }
    196            /* If the requested audio frequency is not the default, compute the prescaler */
    197            else
    198            {
    199              /* Check the frame length (For the Prescaler computing) */
    200              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0:
   \   00000026   0x88A8             LDRH     R0,[R5, #+4]
   \   00000028   0xB100             CBZ.N    R0,??I2S_Init_2
    201              {
    202                /* Packet length is 16 bits */
    203                packetlength = 1;
    204              }
    205              else
    206              {
    207                /* Packet length is 32 bits */
    208                packetlength = 2;
   \   0000002A   0x2702             MOVS     R7,#+2
    209              }
    210              /* Get System Clock frequency */
    211              RCC_GetClocksFreq(&RCC_Clocks);
   \                     ??I2S_Init_2:
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       RCC_GetClocksFreq
    212              
    213              /* Compute the Real divider depending on the MCLK output state with a flaoting point */
    214              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   00000032   0x8928             LDRH     R0,[R5, #+8]
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   0000003A   0x0051             LSLS     R1,R2,#+1
   \   0000003C   0x88EA             LDRH     R2,[R5, #+6]
   \   0000003E   0xF5B2 0x7F00      CMP      R2,#+512
   \   00000042   0xBF0E             ITEE     EQ 
   \   00000044   0x0200             LSLEQ    R0,R0,#+8
   \   00000046   0x4378             MULNE    R0,R0,R7
   \   00000048   0x0140             LSLNE    R0,R0,#+5
    215              {
    216                /* MCLK output is enabled */
    217                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct->I2S_AudioFreq)) + 5);
    218              }
    219              else
    220              {
    221                /* MCLK output is disabled */
    222                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   0000004A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000004E   0x1D40             ADDS     R0,R0,#+5
   \   00000050   0xB280             UXTH     R0,R0
    223              }
    224              
    225              /* Remove the flaoting point */
    226              tmp = tmp/10;  
   \   00000052   0x210A             MOVS     R1,#+10
   \   00000054   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    227                
    228              /* Check the parity of the divider */
    229              i2sodd = (u16)(tmp & (u16)0x0001);
   \   00000058   0xF000 0x0201      AND      R2,R0,#0x1
    230             
    231              /* Compute the i2sdiv prescaler */
    232              i2sdiv = (u16)((tmp - i2sodd) / 2);
   \   0000005C   0x1A80             SUBS     R0,R0,R2
   \   0000005E   0x03C1             LSLS     R1,R0,#+15
   \   00000060   0x0C09             LSRS     R1,R1,#+16
    233             
    234              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    235              i2sodd = (u16) (i2sodd << 8);
   \   00000062   0x0210             LSLS     R0,R2,#+8
    236            }
    237            
    238            /* Test if the divider is 1 or 0 */
    239            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_1:
   \   00000064   0x1E8A             SUBS     R2,R1,#+2
   \   00000066   0x2AFE             CMP      R2,#+254
   \   00000068   0xBF24             ITT      CS 
   \   0000006A   0x2102             MOVCS    R1,#+2
   \   0000006C   0x2000             MOVCS    R0,#+0
    240            {
    241              /* Set the default values */
    242              i2sdiv = 2;
    243              i2sodd = 0;
    244            }
    245          
    246            /* Write to SPIx I2SPR register the computed value */
    247            SPIx->I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct->I2S_MCLKOutput);  
   \   0000006E   0x4308             ORRS     R0,R0,R1
   \   00000070   0x88E9             LDRH     R1,[R5, #+6]
   \   00000072   0x4308             ORRS     R0,R1,R0
   \   00000074   0x8420             STRH     R0,[R4, #+32]
    248           
    249            /* Configure the I2S with the SPI_InitStruct values */
    250            tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct->I2S_Mode | \
    251                            I2S_InitStruct->I2S_Standard | I2S_InitStruct->I2S_DataFormat | \
    252                            I2S_InitStruct->I2S_CPOL);
    253           
    254            /* Write to SPIx I2SCFGR */  
    255            SPIx->I2SCFGR = tmpreg;                                    
   \   00000076   0x8828             LDRH     R0,[R5, #+0]
   \   00000078   0x4330             ORRS     R0,R0,R6
   \   0000007A   0x8869             LDRH     R1,[R5, #+2]
   \   0000007C   0x4308             ORRS     R0,R1,R0
   \   0000007E   0x88A9             LDRH     R1,[R5, #+4]
   \   00000080   0x4308             ORRS     R0,R1,R0
   \   00000082   0x8969             LDRH     R1,[R5, #+10]
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0xF440 0x6000      ORR      R0,R0,#0x800
   \   0000008A   0x83A0             STRH     R0,[R4, #+28]
    256          }
   \   0000008C   0xB005             ADD      SP,SP,#+20
   \   0000008E   0xBDF0             POP      {R4-R7,PC}       ;; return
    257          
    258          /*******************************************************************************
    259          * Function Name  : SPI_StructInit
    260          * Description    : Fills each SPI_InitStruct member with its default value.
    261          * Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
    262          *                    which will be initialized.
    263          * Output         : None
    264          * Return         : None
    265          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    267          {
    268          /*--------------- Reset SPI init structure parameters values -----------------*/
    269            /* Initialize the SPI_Direction member */
    270            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    271          
    272            /* initialize the SPI_Mode member */
    273            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    274          
    275            /* initialize the SPI_DataSize member */
    276            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    277          
    278            /* Initialize the SPI_CPOL member */
    279            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    280          
    281            /* Initialize the SPI_CPHA member */
    282            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
    283          
    284            /* Initialize the SPI_NSS member */
    285            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   0000000C   0x8141             STRH     R1,[R0, #+10]
    286          
    287            /* Initialize the SPI_BaudRatePrescaler member */
    288            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    289          
    290            /* Initialize the SPI_FirstBit member */
    291            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000010   0x81C1             STRH     R1,[R0, #+14]
    292          
    293            /* Initialize the SPI_CRCPolynomial member */
    294            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000012   0x2107             MOVS     R1,#+7
   \   00000014   0x8201             STRH     R1,[R0, #+16]
    295          }
   \   00000016   0x4770             BX       LR               ;; return
    296          
    297          /*******************************************************************************
    298          * Function Name  : I2S_StructInit
    299          * Description    : Fills each I2S_InitStruct member with its default value.
    300          * Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
    301          *                    which will be initialized.
    302          * Output         : None
    303          * Return         : None
    304          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    305          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    306          {
    307          /*--------------- Reset I2S init structure parameters values -----------------*/
    308            /* Initialize the I2S_Mode member */
    309            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    310            
    311            /* Initialize the I2S_Standard member */
    312            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    313            
    314            /* Initialize the I2S_DataFormat member */
    315            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    316            
    317            /* Initialize the I2S_MCLKOutput member */
    318            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    319            
    320            /* Initialize the I2S_AudioFreq member */
    321            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x8101             STRH     R1,[R0, #+8]
    322            
    323            /* Initialize the I2S_CPOL member */
    324            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8141             STRH     R1,[R0, #+10]
    325          }
   \   00000012   0x4770             BX       LR               ;; return
    326          
    327          /*******************************************************************************
    328          * Function Name  : SPI_Cmd
    329          * Description    : Enables or disables the specified SPI peripheral.
    330          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    331          *                  - NewState: new state of the SPIx peripheral. 
    332          *                    This parameter can be: ENABLE or DISABLE.
    333          * Output         : None
    334          * Return         : None
    335          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    336          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    337          {
    338            /* Check the parameters */
    339            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    340            assert_param(IS_FUNCTIONAL_STATE(NewState));
    341          
    342            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0140      ORRNE    R1,R1,#0x40
   \   0000000A   0xF64F 0x72BF      MOVWEQ   R2,#+65471
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    343            {
    344              /* Enable the selected SPI peripheral */
    345              SPIx->CR1 |= CR1_SPE_Set;
    346            }
    347            else
    348            {
    349              /* Disable the selected SPI peripheral */
    350              SPIx->CR1 &= CR1_SPE_Reset;
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    351            }
    352          }
   \   00000012   0x4770             BX       LR               ;; return
    353          
    354          /*******************************************************************************
    355          * Function Name  : I2S_Cmd
    356          * Description    : Enables or disables the specified SPI peripheral (in I2S mode).
    357          * Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
    358          *                  - NewState: new state of the SPIx peripheral. 
    359          *                    This parameter can be: ENABLE or DISABLE.
    360          * Output         : None
    361          * Return         : None
    362          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    363          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    364          {
    365            /* Check the parameters */
    366            assert_param(IS_SPI_23_PERIPH(SPIx));
    367            assert_param(IS_FUNCTIONAL_STATE(NewState));
    368          
    369            if (NewState != DISABLE)
   \                     I2S_Cmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8B81             LDRH     R1,[R0, #+28]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF441 0x6180      ORRNE    R1,R1,#0x400
   \   0000000A   0xF64F 0x32FF      MOVWEQ   R2,#+64511
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    370            {
    371              /* Enable the selected SPI peripheral (in I2S mode) */
    372              SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
    373            }
    374            else
    375            {
    376              /* Disable the selected SPI peripheral (in I2S mode) */
    377              SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
   \   00000010   0x8381             STRH     R1,[R0, #+28]
    378            }
    379          }
   \   00000012   0x4770             BX       LR               ;; return
    380          
    381          /*******************************************************************************
    382          * Function Name  : SPI_I2S_ITConfig
    383          * Description    : Enables or disables the specified SPI/I2S interrupts.
    384          * Input          : - SPIx: where x can be :
    385          *                         - 1, 2 or 3 in SPI mode 
    386          *                         - 2 or 3 in I2S mode
    387          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
    388          *                    enabled or disabled. 
    389          *                    This parameter can be one of the following values:
    390          *                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    391          *                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    392          *                       - SPI_I2S_IT_ERR: Error interrupt mask
    393          *                  - NewState: new state of the specified SPI/I2S interrupt.
    394          *                    This parameter can be: ENABLE or DISABLE.
    395          * Output         : None
    396          * Return         : None
    397          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    398          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
    399          {
    400            u16 itpos = 0, itmask = 0 ;
    401          
    402            /* Check the parameters */
    403            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    404            assert_param(IS_FUNCTIONAL_STATE(NewState));
    405            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
    406          
    407            /* Get the SPI/I2S IT index */
    408            itpos = SPI_I2S_IT >> 4;
    409            /* Set the IT mask */
    410            itmask = (u16)((u16)1 << itpos);
   \                     SPI_I2S_ITConfig:
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x0909             LSRS     R1,R1,#+4
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0xB289             UXTH     R1,R1
    411          
    412            if (NewState != DISABLE)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0x8882             LDRH     R2,[R0, #+4]
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x4311             ORRNE    R1,R1,R2
   \   00000012   0xEA22 0x0101      BICEQ    R1,R2,R1
    413            {
    414              /* Enable the selected SPI/I2S interrupt */
    415              SPIx->CR2 |= itmask;
    416            }
    417            else
    418            {
    419              /* Disable the selected SPI/I2S interrupt */
    420              SPIx->CR2 &= (u16)~itmask;
   \   00000016   0x8081             STRH     R1,[R0, #+4]
    421            }
    422          }
   \   00000018   0x4770             BX       LR               ;; return
    423          
    424          /*******************************************************************************
    425          * Function Name  : SPI_I2S_DMACmd
    426          * Description    : Enables or disables the SPIx/I2Sx DMA interface.
    427          * Input          : - SPIx: where x can be :
    428          *                         - 1, 2 or 3 in SPI mode 
    429          *                         - 2 or 3 in I2S mode
    430          *                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
    431          *                    to be enabled or disabled. 
    432          *                    This parameter can be any combination of the following values:
    433          *                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    434          *                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    435          *                  - NewState: new state of the selected SPI/I2S DMA transfer 
    436          *                    request.
    437          *                    This parameter can be: ENABLE or DISABLE.
    438          * Output         : None
    439          * Return         : None
    440          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    441          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
    442          {
    443            /* Check the parameters */
    444            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    447          
    448            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd:
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x8882             LDRH     R2,[R0, #+4]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0xEA22 0x0101      BICEQ    R1,R2,R1
    449            {
    450              /* Enable the selected SPI/I2S DMA requests */
    451              SPIx->CR2 |= SPI_I2S_DMAReq;
    452            }
    453            else
    454            {
    455              /* Disable the selected SPI/I2S DMA requests */
    456              SPIx->CR2 &= (u16)~SPI_I2S_DMAReq;
   \   0000000C   0x8081             STRH     R1,[R0, #+4]
    457            }
    458          }
   \   0000000E   0x4770             BX       LR               ;; return
    459          
    460          /*******************************************************************************
    461          * Function Name  : SPI_I2S_SendData
    462          * Description    : Transmits a Data through the SPIx/I2Sx peripheral.
    463          * Input          : - SPIx: where x can be :
    464          *                         - 1, 2 or 3 in SPI mode 
    465          *                         - 2 or 3 in I2S mode
    466          *                  - Data : Data to be transmitted..
    467          * Output         : None
    468          * Return         : None
    469          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    470          void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
    471          {
    472            /* Check the parameters */
    473            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    474            
    475            /* Write in the DR register the data to be sent */
    476            SPIx->DR = Data;
   \                     SPI_I2S_SendData:
   \   00000000   0x8181             STRH     R1,[R0, #+12]
    477          }
   \   00000002   0x4770             BX       LR               ;; return
    478          
    479          /*******************************************************************************
    480          * Function Name  : SPI_I2S_ReceiveData
    481          * Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
    482          * Input          : - SPIx: where x can be :
    483          *                         - 1, 2 or 3 in SPI mode 
    484          *                         - 2 or 3 in I2S mode
    485          * Output         : None
    486          * Return         : The value of the received data.
    487          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    488          u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    492            
    493            /* Return the data in the DR register */
    494            return SPIx->DR;
   \                     SPI_I2S_ReceiveData:
   \   00000000   0x8980             LDRH     R0,[R0, #+12]
   \   00000002   0x4770             BX       LR               ;; return
    495          }
    496          
    497          /*******************************************************************************
    498          * Function Name  : SPI_NSSInternalSoftwareConfig
    499          * Description    : Configures internally by software the NSS pin for the selected 
    500          *                  SPI.
    501          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    502          *                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    503          *                    This parameter can be one of the following values:
    504          *                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
    505          *                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    506          * Output         : None
    507          * Return         : None
    508          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    509          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
    510          {
    511            /* Check the parameters */
    512            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    513            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    514          
    515            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig:
   \   00000000   0xF64F 0x62FF      MOVW     R2,#+65279
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0xF441 0x7180      ORRNE    R1,R1,#0x100
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    516            {
    517              /* Set NSS pin internally by software */
    518              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
    519            }
    520            else
    521            {
    522              /* Reset NSS pin internally by software */
    523              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    524            }
    525          }
   \   00000012   0x4770             BX       LR               ;; return
    526          
    527          /*******************************************************************************
    528          * Function Name  : SPI_SSOutputCmd
    529          * Description    : Enables or disables the SS output for the selected SPI.
    530          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    531          *                  - NewState: new state of the SPIx SS output. 
    532          *                    This parameter can be: ENABLE or DISABLE.
    533          * Output         : None
    534          * Return         : None
    535          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    536          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    537          {
    538            /* Check the parameters */
    539            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    540            assert_param(IS_FUNCTIONAL_STATE(NewState));
    541          
    542            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0104      ORRNE    R1,R1,#0x4
   \   0000000A   0xF64F 0x72FB      MOVWEQ   R2,#+65531
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    543            {
    544              /* Enable the selected SPI SS output */
    545              SPIx->CR2 |= CR2_SSOE_Set;
    546            }
    547            else
    548            {
    549              /* Disable the selected SPI SS output */
    550              SPIx->CR2 &= CR2_SSOE_Reset;
   \   00000010   0x8081             STRH     R1,[R0, #+4]
    551            }
    552          }
   \   00000012   0x4770             BX       LR               ;; return
    553          
    554          /*******************************************************************************
    555          * Function Name  : SPI_DataSizeConfig
    556          * Description    : Configures the data size for the selected SPI.
    557          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    558          *                  - SPI_DataSize: specifies the SPI data size.
    559          *                    This parameter can be one of the following values:
    560          *                       - SPI_DataSize_16b: Set data frame format to 16bit
    561          *                       - SPI_DataSize_8b: Set data frame format to 8bit
    562          * Output         : None
    563          * Return         : None
    564          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    565          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
    566          {
    567            /* Check the parameters */
    568            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    569            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    570          
    571            /* Clear DFF bit */
    572            SPIx->CR1 &= (u16)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8002             STRH     R2,[R0, #+0]
    573            /* Set new DFF bit value */
    574            SPIx->CR1 |= SPI_DataSize;
   \   0000000A   0x8802             LDRH     R2,[R0, #+0]
   \   0000000C   0x4311             ORRS     R1,R1,R2
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    575          }
   \   00000010   0x4770             BX       LR               ;; return
    576          
    577          /*******************************************************************************
    578          * Function Name  : SPI_TransmitCRC
    579          * Description    : Transmit the SPIx CRC value.
    580          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    581          * Output         : None
    582          * Return         : None
    583          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    584          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    585          {
    586            /* Check the parameters */
    587            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    588            
    589            /* Enable the selected SPI CRC transmission */
    590            SPIx->CR1 |= CR1_CRCNext_Set;
   \                     SPI_TransmitCRC:
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \   00000002   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    591          }
   \   00000008   0x4770             BX       LR               ;; return
    592          
    593          /*******************************************************************************
    594          * Function Name  : SPI_CalculateCRC
    595          * Description    : Enables or disables the CRC value calculation of the
    596          *                  transfered bytes.
    597          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    598          *                  - NewState: new state of the SPIx CRC value calculation.
    599          *                    This parameter can be: ENABLE or DISABLE.
    600          * Output         : None
    601          * Return         : None
    602          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    603          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    604          {
    605            /* Check the parameters */
    606            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    607            assert_param(IS_FUNCTIONAL_STATE(NewState));
    608          
    609            if (NewState != DISABLE)
   \                     SPI_CalculateCRC:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF441 0x5100      ORRNE    R1,R1,#0x2000
   \   0000000A   0xF64D 0x72FF      MOVWEQ   R2,#+57343
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    610            {
    611              /* Enable the selected SPI CRC calculation */
    612              SPIx->CR1 |= CR1_CRCEN_Set;
    613            }
    614            else
    615            {
    616              /* Disable the selected SPI CRC calculation */
    617              SPIx->CR1 &= CR1_CRCEN_Reset;
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    618            }
    619          }
   \   00000012   0x4770             BX       LR               ;; return
    620          
    621          /*******************************************************************************
    622          * Function Name  : SPI_GetCRC
    623          * Description    : Returns the transmit or the receive CRC register value for
    624          *                  the specified SPI.
    625          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    626          *                  - SPI_CRC: specifies the CRC register to be read.
    627          *                    This parameter can be one of the following values:
    628          *                       - SPI_CRC_Tx: Selects Tx CRC register
    629          *                       - SPI_CRC_Rx: Selects Rx CRC register
    630          * Output         : None
    631          * Return         : The selected CRC register value..
    632          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    633          u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
    634          {
    635            u16 crcreg = 0;
    636          
    637            /* Check the parameters */
    638            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    639            assert_param(IS_SPI_CRC(SPI_CRC));
    640          
    641            if (SPI_CRC != SPI_CRC_Rx)
   \                     SPI_GetCRC:
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD001             BEQ.N    ??SPI_GetCRC_0
    642            {
    643              /* Get the Tx CRC register */
    644              crcreg = SPIx->TXCRCR;
   \   00000004   0x8B00             LDRH     R0,[R0, #+24]
   \   00000006   0x4770             BX       LR
    645            }
    646            else
    647            {
    648              /* Get the Rx CRC register */
    649              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0:
   \   00000008   0x8A80             LDRH     R0,[R0, #+20]
    650            }
    651          
    652            /* Return the selected CRC register */
    653            return crcreg;
   \   0000000A   0x4770             BX       LR               ;; return
    654          }
    655          
    656          /*******************************************************************************
    657          * Function Name  : SPI_GetCRCPolynomial
    658          * Description    : Returns the CRC Polynomial register value for the specified SPI.
    659          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    660          * Output         : None
    661          * Return         : The CRC Polynomial register value.
    662          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    663          u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    664          {
    665            /* Check the parameters */
    666            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    667            
    668            /* Return the CRC polynomial register */
    669            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial:
   \   00000000   0x8A00             LDRH     R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    670          }
    671          
    672          /*******************************************************************************
    673          * Function Name  : SPI_BiDirectionalLineConfig
    674          * Description    : Selects the data transfer direction in bi-directional mode
    675          *                  for the specified SPI.
    676          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    677          *                  - SPI_Direction: specifies the data transfer direction in
    678          *                    bi-directional mode. 
    679          *                    This parameter can be one of the following values:
    680          *                       - SPI_Direction_Tx: Selects Tx transmission direction
    681          *                       - SPI_Direction_Rx: Selects Rx receive direction
    682          * Output         : None
    683          * Return         : None
    684          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    685          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
    686          {
    687            /* Check the parameters */
    688            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    689            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    690          
    691            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig:
   \   00000000   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
   \   00000006   0xBF0E             ITEE     EQ 
   \   00000008   0xF441 0x4180      ORREQ    R1,R1,#0x4000
   \   0000000C   0xF64B 0x72FF      MOVWNE   R2,#+49151
   \   00000010   0x4011             ANDNE    R1,R2,R1
    692            {
    693              /* Set the Tx only mode */
    694              SPIx->CR1 |= SPI_Direction_Tx;
    695            }
    696            else
    697            {
    698              /* Set the Rx only mode */
    699              SPIx->CR1 &= SPI_Direction_Rx;
   \   00000012   0x8001             STRH     R1,[R0, #+0]
    700            }
    701          }
   \   00000014   0x4770             BX       LR               ;; return
    702          
    703          /*******************************************************************************
    704          * Function Name  : SPI_I2S_GetFlagStatus
    705          * Description    : Checks whether the specified SPI/I2S flag is set or not.
    706          * Input          : - SPIx: where x can be :
    707          *                         - 1, 2 or 3 in SPI mode 
    708          *                         - 2 or 3 in I2S mode
    709          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
    710          *                    This parameter can be one of the following values:
    711          *                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
    712          *                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
    713          *                       - SPI_I2S_FLAG_BSY: Busy flag.
    714          *                       - SPI_I2S_FLAG_OVR: Overrun flag.
    715          *                       - SPI_FLAG_MODF: Mode Fault flag.
    716          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    717          *                       - I2S_FLAG_UDR: Underrun Error flag.
    718          *                       - I2S_FLAG_CHSIDE: Channel Side flag.
    719          * Output         : None
    720          * Return         : The new state of SPI_I2S_FLAG (SET or RESET).
    721          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    722          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    723          {
    724            FlagStatus bitstatus = RESET;
   \                     SPI_I2S_GetFlagStatus:
   \   00000000   0x2200             MOVS     R2,#+0
    725          
    726            /* Check the parameters */
    727            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    728            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
    729          
    730            /* Check the status of the specified SPI/I2S flag */
    731            if ((SPIx->SR & SPI_I2S_FLAG) != (u16)RESET)
   \   00000002   0x8900             LDRH     R0,[R0, #+8]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
    732            {
    733              /* SPI_I2S_FLAG is set */
    734              bitstatus = SET;
    735            }
    736            else
    737            {
    738              /* SPI_I2S_FLAG is reset */
    739              bitstatus = RESET;
    740            }
    741            /* Return the SPI_I2S_FLAG status */
    742            return  bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    743          }
    744          
    745          /*******************************************************************************
    746          * Function Name  : SPI_I2S_ClearFlag
    747          * Description    : Clears the SPIx/I2Sx pending flags.
    748          * Input          : - SPIx: where x can be :
    749          *                         - 1, 2 or 3 in SPI mode 
    750          *                         - 2 or 3 in I2S mode
    751          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to clear. 
    752          *                    This parameter can be one of the following values:
    753          *                       - SPI_I2S_FLAG_OVR: Overrun flag 
    754          *                       - SPI_FLAG_MODF: Mode Fault flag.
    755          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    756          *                       - I2S_FLAG_UDR: Underrun Error flag.
    757          *                    Note: Before clearing OVR flag, it is mandatory to read 
    758          *                          SPI_I2S_DR register, so that the last data is not lost.
    759          * Output         : None
    760          * Return         : None
    761          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    762          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    763          {
    764            /* Check the parameters */
    765            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    766            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    767              
    768            /* SPI_FLAG_MODF flag clear */
    769            if(SPI_I2S_FLAG == SPI_FLAG_MODF)
   \                     SPI_I2S_ClearFlag:
   \   00000000   0x2920             CMP      R1,#+32
   \   00000002   0xD100             BNE.N    ??SPI_I2S_ClearFlag_0
    770            {
    771              /* Read SR register */
    772              (void)SPIx->SR;
   \   00000004   0x....             B.N      ?Subroutine0
    773              
    774              /* Write on CR1 register */
    775              SPIx->CR1 |= CR1_SPE_Set; 
    776            }
    777            /* SPI_I2S_FLAG_OVR flag or I2S_FLAG_UDR flag clear */
    778            else if ((SPI_I2S_FLAG == SPI_I2S_FLAG_OVR) || (SPI_I2S_FLAG == I2S_FLAG_UDR))  
   \                     ??SPI_I2S_ClearFlag_0:
   \   00000006   0x2940             CMP      R1,#+64
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2908             CMPNE    R1,#+8
   \   0000000C   0xD101             BNE.N    ??SPI_I2S_ClearFlag_1
    779            {
    780              /* Read SR register  (Before clearing OVR flag, it is mandatory to read 
    781                 SPI_I2S_DR register)*/
    782              (void)SPIx->SR;
   \   0000000E   0x8900             LDRH     R0,[R0, #+8]
   \   00000010   0x4770             BX       LR
    783            }
    784            else /* SPI_FLAG_CRCERR flag clear */
    785            {
    786              /* Clear the selected SPI flag */
    787              SPIx->SR = (u16)~SPI_I2S_FLAG;
   \                     ??SPI_I2S_ClearFlag_1:
   \   00000012   0x....             B.N      ?Subroutine1
    788            }
    789          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x43C9             MVNS     R1,R1
   \   00000002   0x8101             STRH     R1,[R0, #+8]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x8901             LDRH     R1,[R0, #+8]
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000008   0x8001             STRH     R1,[R0, #+0]
   \   0000000A   0x4770             BX       LR
    790          
    791          /*******************************************************************************
    792          * Function Name  : SPI_I2S_GetITStatus
    793          * Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
    794          * Input          : - SPIx: where x can be :
    795          *                         - 1, 2 or 3 in SPI mode 
    796          *                         - 2 or 3 in I2S mode
    797          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
    798          *                    This parameter can be one of the following values:
    799          *                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
    800          *                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
    801          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    802          *                       - SPI_IT_MODF: Mode Fault interrupt.
    803          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    804          *                       - I2S_IT_UDR: Underrun Error interrupt.
    805          * Output         : None
    806          * Return         : The new state of SPI_I2S_IT (SET or RESET).
    807          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    808          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    809          {
   \                     SPI_I2S_GetITStatus:
   \   00000000   0xB430             PUSH     {R4,R5}
    810            ITStatus bitstatus = RESET;
   \   00000002   0x2200             MOVS     R2,#+0
    811            u16 itpos = 0, itmask = 0, enablestatus = 0;
    812          
    813            /* Check the parameters */
    814            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    815            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
    816          
    817            /* Get the SPI/I2S IT index */
    818            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
    819          
    820            /* Get the SPI/I2S IT mask */
    821            itmask = SPI_I2S_IT >> 4;
    822            /* Set the IT mask */
    823            itmask = (u16)((u16)0x01 << itmask);
    824            /* Get the SPI_I2S_IT enable bit status */
    825            enablestatus = (SPIx->CR2 & itmask) ;
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x8884             LDRH     R4,[R0, #+4]
   \   00000008   0x090D             LSRS     R5,R1,#+4
   \   0000000A   0xFA03 0xF505      LSL      R5,R3,R5
   \   0000000E   0x402C             ANDS     R4,R5,R4
    826          
    827            /* Check the status of the specified SPI/I2S interrupt */
    828            if (((SPIx->SR & itpos) != (u16)RESET) && enablestatus)
   \   00000010   0x8900             LDRH     R0,[R0, #+8]
   \   00000012   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000016   0xFA03 0xF101      LSL      R1,R3,R1
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x2C00             CMPNE    R4,#+0
   \   00000020   0x2201             MOVNE    R2,#+1
    829            {
    830              /* SPI_I2S_IT is set */
    831              bitstatus = SET;
    832            }
    833            else
    834            {
    835              /* SPI_I2S_IT is reset */
    836              bitstatus = RESET;
    837            }
    838            /* Return the SPI_I2S_IT status */
    839            return bitstatus;
   \   00000022   0x4610             MOV      R0,R2
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
    840          }
    841          
    842          /*******************************************************************************
    843          * Function Name  : SPI_I2S_ClearITPendingBit
    844          * Description    : Clears the SPIx/I2Sx interrupt pending bits.
    845          * Input          : - SPIx: where x can be :
    846          *                         - 1, 2 or 3 in SPI mode 
    847          *                         - 2 or 3 in I2S mode
    848          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt pending bit to clear.
    849          *                    This parameter can be one of the following values:
    850          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    851          *                       - SPI_IT_MODF: Mode Fault interrupt.
    852          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    853          *                       - I2S_IT_UDR: Underrun Error interrupt.
    854          * Output         : None
    855          * Return         : None
    856          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    857          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    858          {
    859            u16 itpos = 0;
    860          
    861            /* Check the parameters */
    862            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    863            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
    864          
    865            /* SPI_IT_MODF pending bit clear */
    866            if(SPI_I2S_IT == SPI_IT_MODF)
   \                     SPI_I2S_ClearITPendingBit:
   \   00000000   0x2955             CMP      R1,#+85
   \   00000002   0xD100             BNE.N    ??SPI_I2S_ClearITPendingBit_0
    867            {
    868              /* Read SR register */
    869              (void)SPIx->SR;
   \   00000004   0x....             B.N      ?Subroutine0
    870              /* Write on CR1 register */
    871              SPIx->CR1 |= CR1_SPE_Set; 
    872            }
    873            /* SPI_I2S_IT_OVR or I2S_IT_UDR pending bit clear */ 
    874            else if((SPI_I2S_IT == SPI_I2S_IT_OVR) || (SPI_I2S_IT == I2S_IT_UDR))    
   \                     ??SPI_I2S_ClearITPendingBit_0:
   \   00000006   0x2956             CMP      R1,#+86
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2953             CMPNE    R1,#+83
   \   0000000C   0xD101             BNE.N    ??SPI_I2S_ClearITPendingBit_1
    875            {
    876              /* Read SR register */
    877              (void)(SPIx->SR);
   \   0000000E   0x8900             LDRH     R0,[R0, #+8]
   \   00000010   0x4770             BX       LR
    878            }  
    879            else   /* SPI_IT_CRCERR pending bit clear */
    880            {
    881              /* Get the SPI/I2S IT index */
    882              itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
    883              /* Clear the selected SPI/I2S interrupt pending bits */
    884              SPIx->SR = (u16)~itpos;
   \                     ??SPI_I2S_ClearITPendingBit_1:
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000018   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000001C   0xB289             UXTH     R1,R1
   \   0000001E                      REQUIRE ?Subroutine1
   \   0000001E                      ;; // Fall through to label ?Subroutine1
    885            }
    886          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40013000         DC32     0x40013000
    887          
    888          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  I2S_Cmd
       40  I2S_Init
             40 -> RCC_GetClocksFreq
        0  I2S_StructInit
        0  SPI_BiDirectionalLineConfig
        0  SPI_CalculateCRC
        0  SPI_Cmd
        0  SPI_DataSizeConfig
        0  SPI_GetCRC
        0  SPI_GetCRCPolynomial
        0  SPI_I2S_ClearFlag
        0  SPI_I2S_ClearITPendingBit
        0  SPI_I2S_DMACmd
        8  SPI_I2S_DeInit
              0 -> RCC_APB1PeriphResetCmd
              8 -> RCC_APB1PeriphResetCmd
              0 -> RCC_APB2PeriphResetCmd
              8 -> RCC_APB2PeriphResetCmd
        0  SPI_I2S_GetFlagStatus
        8  SPI_I2S_GetITStatus
        0  SPI_I2S_ITConfig
        0  SPI_I2S_ReceiveData
        0  SPI_I2S_SendData
        0  SPI_Init
        0  SPI_NSSInternalSoftwareConfig
        0  SPI_SSOutputCmd
        0  SPI_StructInit
        0  SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
      12  ?Subroutine0
       6  ?Subroutine1
      20  I2S_Cmd
     144  I2S_Init
      20  I2S_StructInit
      22  SPI_BiDirectionalLineConfig
      20  SPI_CalculateCRC
      20  SPI_Cmd
      18  SPI_DataSizeConfig
      12  SPI_GetCRC
       4  SPI_GetCRCPolynomial
      20  SPI_I2S_ClearFlag
      30  SPI_I2S_ClearITPendingBit
      16  SPI_I2S_DMACmd
      88  SPI_I2S_DeInit
      14  SPI_I2S_GetFlagStatus
      40  SPI_I2S_GetITStatus
      26  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData
       4  SPI_I2S_SendData
      56  SPI_Init
      20  SPI_NSSInternalSoftwareConfig
      20  SPI_SSOutputCmd
      24  SPI_StructInit
      10  SPI_TransmitCRC

 
 682 bytes in section .text
 
 682 bytes of CODE memory

Errors: none
Warnings: none
